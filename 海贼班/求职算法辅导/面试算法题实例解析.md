### 判断链表是否交叉

题目：给定两个链表，长度分别为 n 和 m，判断它们是否交叉

1. 暴力解，对于第一个链表的每一个结点，去遍历另一个链表看有没有出现该结点。O(nm)

2. 先算两链表长度差n-m，让长的链表先向后遍历n-m个结点，如此两个链表剩下的未遍历结点个数相等。然后两链表同时向后遍历，如果遍历到同一个结点说明链表交叉。O(n+m)
3. 将一个链表首尾相接，从另一个链表的表头开始遍历，判断是否有环(通过hash实现)，有环说明链表交叉。O(n+m)

对于面试官来说，有两类预期的解题过程： 

- 顺利地说出后两种解法之一，并准确地写出代码 
- 先说出最暴力的方法，之后给出一种优化后的算法 

这两种算法无所谓优劣，如果你直接就想出最优的算法也没必要故意先说出一个不够优化的算法再给出改进，尽快说出最优算法可以让面试官在后面的题目中发现你更多的闪光点。当然，如果你对自己的算法设计能力没有信心，那么“拖延时间”也不失为一个取巧的策略。

### 随机数生成器

题目：给定一个函数fun()，会以 p 的概率返回 1，1−p 的概率返回 0。写出一个函数，使得这个函数返回 0 和 1 的概率均为 0.5。

因为func()以 p 概率生成 1，1−p 概率生成 0，如果生成两个随机数 a,b，那么 a×b=1 有两种情况：a=1,b=0、a=0,b=1，这两种情况的概率相等。

```cpp
int get(){
    int a = func(), b = func();
    if(a == 1 && b == 0) {
        return 1;
    } else if(a == 0 && b == 1) {
        return 0;
    } else {
        return get();
    }
}
```

通常来说，这类题目答不上来也不要紧，但无论如何一定要给出一些思路，以体现出你的思考能力。