### 单链表

链表的核心思想：整个链表通过每个元素指向下一个元素串联起来。由于链表的串联性质，通常只保留链表第一个元素的地址，并用存储这个地址的指针（Java 中的引用）表示整个链表。

```cpp
struct ListNode{
    int val;
    ListNode *next;
    ListNode(int _val):val(_val),next(NULL){}
}
```

##### 插入

```cpp
ListNode *insert(ListNode *head, int index, ListNode *node){
    if(head == NULL){
        if(index!=0)return head;
        head = node;
        return head;
    }
    if(index == 0){
        node->next = head;
        head = node;
        return head;
    }
    ListNode *current_node = head;
    int count = 0;
    while(current_node->next!=NULL && count<index-1){
        current_node = current_node->next;
        count++;
    }
    if(count==index-1){
        node->next = current_node->next;
        current_node->next = node;
    }
    return head;
}
```

##### 删除

```cpp
ListNode *remove(ListNode *head, int index){
    if(head == NULL) return head;
    ListNode *current_node = head;
    int count = 0;
    if(index == 0){
        head = head->next;
        delete current_node;
        return head;
    }
    while(current_node->next!=NULL && count<index-1){
        current_node = current_node->next;
        count++;
    }
    if(count==index-1&&current_node->next!=NULL){
        ListNode *delete_node = current_node->next;
        current_node->next = delete_node_next;
        delete delete_node;
    }
    return head;
}
```



### 常见链表问题 

基于链表的定义和插入、删除操作思想，有很多常见的链表问题，接下来会为你介绍其中的几个最经典的例子，及其解法和示例代码。 

##### 统计链表中的结点个数 

对于给定的链表，统计其中一共有多少个结点。 思路：仿照前面插入和删除操作中的 while 循环，从表头head开始遍历，直到NULL结束。时间复杂度为 O(n)。

```cpp
int get_length(ListNode *head){
    int count = 0;
    while(head!=NULL){
        count++;
        head=head->next;
    }
    return count;
}
```

##### 找出倒数第 K 个结点 

对于给定的链表，找出倒数第 k 个结点的元素。 

思路 1：先统计出链表中的结点个数 n，之后从前往后找到第 n-k+1个结点。时间复杂度为 O(n)。

```cpp
ListNode *get_kth(ListNode *head, int k) {
    if(k<=0||k>n)return NULL;
    int n = get_length(head);
    int count = 0;
    for(int i = 0; i<n-k; ++i){
        head = head->next;
    }
    return head;
}
```

思路 2：先让一个指针nextk指向链表第 k个元素，然后让head和nextk同时向后移动，直到nextk为空。时间复杂度为 O(n)。

思路2就是让这两个指针隔着k个位置，当nextk为null时，next就距离它k个结点。

```cpp
ListNode *get_kth(ListNode *head, int k) {
    if(k<=0||k>n)return NULL;
    ListNode *nextk = head;
    for(int i =0; i<k-1; ++i){
        nextk = nextk->next;
    }
    while(nextk != NULL){
        head = head->next;
        nextk = nextk->next;
    }
    return head;
}
```

##### 链表翻转

将给定的链表进行翻转。例如，一个链表中的元素分别为 1,2,3,4,5，则翻转后的结果为 5,4,3,2,1。 

思路 1：新建一个链表，每次把原链表中的第一个元素放到新链表的头部，并把这个元素从原链表中删掉。空间复杂度为O(n)，时间复杂度为 O(n)。

```cpp
ListNode *reverse(ListNode *head, int k) {
	ListNode *new_list = NULL;
    while(head!=NULL){
        ListNode *node = new ListNode(head->val);
        new_list = insert(new_list,0,node);
        head = head->next;
    }
    return new_list;
}
```

思路2：原地翻转，a->b->c。先让a的next指向c，然后把b的next指向a。变成b->a->c。

```cpp
ListNode* reverseLinkedList(ListNode *head) {
    ListNode *next_node = head->next;//指向下一个要翻转的结点
    ListNode *pre_node = head;//指向新链表的头
    while(next_node!=NULL){
        head->next = next_node->next;
        next_node->next = pre_node;
        pre_node = next_node;
        next_node = head->next;
    }
    return pre_node;
}
```

### 链表排序

```

```

