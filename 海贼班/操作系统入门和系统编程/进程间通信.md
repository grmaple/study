在现代的计算机中，进程的地址空间和物理内存是区别开的，除非一个进程与其它进程共享一段内存，否则不同的进程是不能够使用彼此的地址空间的。一些同学肯定已经想到了，如果不同的进程之间不能共享内存，那么它们互相之间该如何通信呢？比如我写了两个程序 A 和 B，B 需要将 A 的输出值作为输入值运行，那我怎么才能达到这个目的呢？

在前面的课程中我们已经学习了fork()，我们可以通过这个系统调用产生一个子进程，然后用exec()在子进程中执行另一个程序，在父进程中调用wait()等待进程运行完毕，但这样我们在父进程中只能获得进程的退出码，这之外的数据我们就无法获得了；而随着子进程的终止，子进程的地址空间也会被系统回收，我们就更无法获得它的数据了。为了能够读取这个数据，我们只有把它存储在一个两个进程都能读取、且不会随着进程的终止而被回收的存储位置，这个位置就是外存。

文件是对外存中存储的数据的抽象，我们可以利用一个文件进行 **进程间的通信**（Inter-process Communication，IPC。进程 A 终止前将输出值写入这个文件，然后进程 B 再将这个文件的内容作为输入值读取进来，开始运行。这是进程间通信的一种常见方法；实际上，一段内存的共享也是通过将一个共享的文件同时映射到两个进程的地址空间实现的。 

另一种进程间通信的方法就是 **信号**（Signal）。信号类似于异常和中断，是异步的；进程在接到信号后在内核态通过对应的信号处理函数来处理该信号。

### 基本I/O操作

我们已经提到，文件是对于外存中存储的数据的抽象，而外存实际上就是磁盘（disk），固态硬盘（SSD，Solid State Drives），磁带（tape）等物理存储设备。这些存储设备与鼠标、键盘、屏幕等无异，都属于 I/O 设备，你可以向这些设备里输入数据，或从这些硬件中获得我们想要的输出数据。因此，从文件中读取数据或向文件中写入数据实际都属于 I/O 的范畴。

I/O 设备是多种多样的，如果我们需要针对每个 I/O 设备的特点写一段不同的代码，那工程量之浩大可想而知。好在操作系统给我们提供了非常便捷的抽象层——无论我们想要使用什么 I/O 设备，我们都可以调用同一组系统调用

第一个系统调用是open()。顾名思义，它是用来打开一个文件的，在每次读写文件以前都必须调用这个函数打开文件，获得一个代表该文件的**文件标识符**，然后再对文件标识符进行操作。与你可能见过的fopen()相比，它处于系统中一个更低的抽象层，你可以对文件进行更基础的操作，但也失去了如fgets(), fscanf()这些方便的库函数的帮助。

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags, mode_t mode);
```

这个函数使用三个参数：pathname是被打开文件的路径；flags表示的是这次打开文件所需要进行的操作；mode可以被省略，只有在创建一个文件的时候才会被需要，表示的是新建文件的使用权限。

几个常用的 flags 的值包括表示创建文件的O_CREAT，表示访问模式的O_RDONLY, O_WRONLY, O_RDWR和表示写入模式的O_APPEND, O_TRUNC。 

O_CREAT表示的是如果这个文件不存在，那么它就将被创建。文件的所有者是正在运行这个进程的用户，拥有这个文件的用户组是这个用户所在的组或这个文件的父目录所属的用户组。这两者对于mode中表示的模式很重要。 

O_RDONLY是 read-only 的缩写，表示这个被打开的文件只能被读取，不能被写入；与它相反的是O_WRONLY，表示这个被打开的文件只能被写入，不能被读取。而O_RDWR表示的则是即可以读也可以写。

O_APPEND和O_TRUNC只有在文件允许写入时才有意义。O_APPEND表示从一个文件的末尾开始写入，而O_TRUNC则表示将文件清空。

mode表示的是被创建的新文件的使用权限，它有固定的格式：前三位都是 S_I，从第四位开始表示权限。如果它表示只有一个权限，则第四位为该权限的缩写（R 表示 read，读，W 表示 write，写，X 表示 execute，执行），后三位为权限的对象（USR 表示 user，用户，GRP 表示用户 group，组，OTH 表示 others，其他用户）。如果它表示三种权限都具备，那么第四位到第六位就是 RWX，最后一位表示权限的对象（U 表示用户，G 表示组，O 表示其他）。

### 文件描述符与dup

如何利用open()返回给我们的 **文件描述符**（file descriptor）。一个文件描述符就是一个整数，用来代表一个被打开的文件。每个文件描述符都对应一个文件内指针，表示这个被打开文件的实例中指针的位置，也就是说如果一个文件被同一个进程打开了多次，那么这几个文件描述符中的指针位置可能是不同的。 

每个系统都对一个进程可以同时打开的文件数量有限制；每个进程都有一个由文件描述符指向文件的 **文件描述符表**（file descriptor table）。open()每次一般会把新打开的文件放到这个表格中的某个空行，然后返回这个文件描述符。需要注意的是，这个文件描述符只是这个进程中代表这个文件的描述符，其它进程即使打开同一个文件也可能有不同的文件描述符；只有由fork()产生的子进程才会有和父进程一样的文件描述符。

文件描述符从 0 开始，但我们不能使用前三个文件描述符，因为它们是事先被规定好的：0 代表标准输入，1 代表标准输出，2 代表标准错误。这三个文件描述符在进程初始时就已经被打开，你可以通过这些文件描述符从标准输入读取内容，或向标准输出和标准错误写入内容。

标准输出正是printf()输出的对象，而标准输入就是你在命令行中输入的内容，因此当我们想把一个进程的输出值导入到一个文件里的时候，我们只需要修改 1，2 这两个文件描述符，使他们输出到我们指定的文件中，我们再用其他进程来读取这个文件。能够实现上述功能的就是下面这个系统调用： 

```cpp
#include <unistd.h>
int dup2(int oldfd, int newfd); 
```

dup2()能够使newfd指向oldfd指向的文件；如果newfd本来对应着其他的文件，那么就关掉原来的文件，再使它指向oldfd指向的文件。通过调用dup2()，我们可以把标准输出和标准错误都关掉，而将 1，2 文件描述符替换为我们想要的文件，这样printf()的内容就会直接导入到我们想要的文件里。

但是这样我们就面临着一个问题——如果我想在一段时间后重新向标准输出输出内容，那我该怎么重新把 1 设定成标准输出呢？为了解决这个问题，我们需要另一个系统调用：

```cpp
#include <unistd.h>
int dup(int oldfd); 
```

dup()会选择最小的空闲文件描述符，使它指向oldfd指向的文件，它返回的是新的指向这个文件的描述符。这样在调用dup2()以前，我们可以先用dup()复制一个指向标准输出的文件描述符，然后用dup2()关闭原来的标准输出的文件描述符。

在应用dup()，dup2()和open()时，我们都不能忘掉检查函数调用确实成功——这三个函数在运行产生错误时，会返回 -1。养成良好的习惯可以大大减少你花在“抓虫”上的时间。

### 读写文件

在介绍了dup()之后，我们来介绍几个实际读写文件时非常实用的系统调用：read()，write()，lseek()，fsync()和close()。 读与写这两个系统调用所需的参数类似，我们把它们放在一起介绍。 

```cpp
#include <unistd.h> 
ssize_t read(int fd, void* buf, size_t count);
ssize_t write(int fd, const void* buf, size_t count); 
```

它们的第一个参数都是fd，是 file descriptor 的缩写，是被读写的文件的文件描述符；第二个参数buf在read()中是用来存储读取的内容的，而在write中代表即将被写入的内容；最后一个参数count代表读写的 最大长度,实际读写的长度可能少于count（比如读取文件时到达了文件的末尾，或写入文件时超过了系统允许的最大长度或资源上限）。如果调用成功，两个函数分别会返回实际读写的长度，否则函数会返回 -1。

read()和write()的参数里有一个比较讨厌，就是count，因为我们不知道这个文件的长度，也不知道一行的长度，读起来就很困难。一种做法是，一次把整个文件都读取到 buffer 中，然后再用处理字符串的函数来获得一行或单个的单词，但这就要求我们获得整个文件的长度。能够帮助我们获得文件长度的就是我们在这一节中要讲的第三个系统调用，lseek()： 

```cpp
#include <sys/types.h> 
#include <unistd.h> 
off_t lseek(int fd, off_t offset, int whence); 
```

每个文件描述符都与一个文件内的指针联系在一起，这个指针会被读写文件改变，但我们也可以直接移动这个指针，这就是lseek()的作用。lseek()的返回值是移动后指针的位置。它的三个参数中，fd是被改变的文件描述符，whence是计算移动目标的起点，而offset就是从whence开始移动的长度。 whence有 3 个常用的值，SEEK_END，SEEK_SET和SEEK_CUR。SEEK_SET和SEEK_END分别代表文件的开头和结尾，而SEEK_CUR代表指针目前的位置。请你自己想一想，下面三个对lseek()的调用分别把指针移到了哪些位置，返回给我们什么信息呢？ 

```cpp
lseek(fd, 0, SEEK_SET); //文件头，返回0
lseek(fd, 0, SEEK_END); //文件尾，返回文件长度
lseek(fd, 0, SEEK_CUR);//文件当前位置，返回当前长度
```

当我们完成了读取文件数据和向文件写入数据的操作后，我们需要注意一点，那就是我们写入的数据可能没有实际被写入磁盘！向外存中写入数据是很花时间的，因此内核为了提高效率会推迟实际写入数据。为了确保我们的数据确实进入了外存，我们需要调用fsync()：

```cpp
int fsync(int fd);
```

这个函数在成功调用时返回0，否则返回-1。

最后，在完成对文件的所有操作后，一定要记得关掉这个文件。在系统中如果有多个进程同时打开了一个文件，而其中一个进程删除了这个文件时，打开这个文件的进程不能突然产生错误，因此内核需要统计一个文件被多少个进程打开，在使用这个文件的进程数为零后再回收这段内存。为了使内核知道我们要将不再使用这个文件，我们需要调用close()：

```cpp
int close(int fd);
```

### 防人之心

我们都知道ls这个命令，在不带任何参数的情况下会在终端中显示出当前目录所包含的所有目录和文件，我们现在想通过ls获得这个文件夹里的所有文件，然后把所有.py结尾的文件清空，并在里面写入“How dare you read my code!”。

```cpp
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <fcntl.h>
#include <regex.h>
int main() {
    int status;
    pid_t child = fork();
    if (child == 0) {
        //先在fork()产生的子进程中将标准输出替换为files.txt。
        int fd = open("files.txt", O_CREAT|O_RDWR, S_IRUSR|S_IWUSR);
        if (fd == -1) {
            printf("Error!\n");
            exit(-1);
        }
        int success = dup2(fd, 1);
        if (success == -1) {
            printf("Error!\n");
            exit(-1);
        }
        //在子进程中直接执行ls这个程序，就需要在子进程中调用execlp()
        //execlp运行成功则ls的输出值被写入了files.txt中
        //找到ls文件，执行ls，无命令行参数，最后参数是NULL
        execlp("ls","ls",(char*)NULL);
        //execlp运行失败执行下面的代码
        printf("Exec failed!\n");
        exit(-1);
    } else {
        wait(&status);
        if (status != 0) {
            printf("Child failed!\n");
            return -1;
        }
    }
    char* to_write = "How dare you read my code!";
    int write_length = strlen(to_write);
    regex_t c_pattern;
    int result;
    if(regcomp(&c_pattern, "[A-Za-z0-9_]*\\.py",0)){
        printf("Compilation failed!\n");
        return -1;
    }
    //在父进程中读取files.txt，并挑出其中的代码文件清空。
    int files = open("files.txt",O_RDONLY);
    if (files == -1) {
        printf("Failed to open files.txt!\n");
        return -1;
    }
    int length = lseek(files, 0, SEEK_END);
    //读取files.txt中ls的输出值。
    lseek(files, 0, SEEK_SET);
    char *buffer = calloc(length,sizeof(char));
    if (read(files, buffer, length) == -1){
        printf("Failed to read!\n");
        return -1;
    }
    //使用strtok()将输出值用换行分隔开
    char *filename = strtok(buffer, "\n");
    while(filename != NULL){
        //使用正则表达式匹配.py文件
        result = regexec(&c_pattern, filename, 0, NULL, 0);
        if(!result){
            //清空.py文件
            int code_file = open(filename, O_WRONLY|O_TRUNC);
            if (code_file == -1){
                printf("Failed to open!\n");
                return -1;
            }
            write(code_file, to_write, write_length);
            fsync(code_file);
            close(code_file);
        } else if(result != REG_NOMATCH){
            printf("Error matching!\n");
            return -1;
        }
        filename = strtok(NULL,"\n");
    }
    close(files);
    return 0;
}
```

### 管道

父进程通过一个文件获得了子进程的输出，然后利用文件中的输出值清空了当前目录下的一些文件。实际上，在这个过程中我们不一定需要一个明确存在的文件，因为我们之后不会再需要子进程输出的文件。我们想要一个像文件一样可以被共享的信息中转站，只用于这次通信，通信之后就自动被移除，这就是 **匿名管道**（pipe）。

用于创建匿名管道的系统调用是：

```cpp
 #include <unistd.h> 
 int pipe(int pipefd[2]); 
//pipefd[0]读取数据的文件描述符
//pipefd[1]写入数据的文件描述符
```

匿名管道是一个单向的数据传输通道，它的两端分别是两个文件描述符，一端的文件描述符只能被用于读取数据，而另一端只能被用于写入数据。pipe()系统调用成功执行时会返回 00，并将传入的数组的第一个元素改为用于读取数据的文件描述符，第二个元素改为用于写入数据的文件描述符；如果系统调用失败，则返回 -1−1。 事实上，在你在终端中输入“<命令> | <命令>”时，你就在两个命令之间建立了一个管道，第一个命令的标准输出通过管道被第二个命令作为标准输入读取。

看到这里你应该会意识到一个很大的问题：文件描述符只在进程的范围内有意义，换到另一个进程中后就不再指向同一个文件了，这怎么办呢？ 

这个问题的答案就是，匿名管道两端的进程必须具有共同祖先；它们从同一个祖先继承了同样的文件描述符表，因此它们的文件描述符指向同一个文件。这是**匿名管道的局限性**，但对于我们上一节中写的程序来讲，匿名管道已经足够了。

```
将一个包含两个整数元素的数组pipefd作为参数调用pipe()；
调用fork()，分出子进程；
在父进程中调用close()关掉pipefd[1];
在父进程中调用dup2(pipefd[1]，0);
在子进程中调用close()关掉pipefd[0];
在子进程中调用dup2(pipefd[1]，1);
```

为了解决这个局限性，我们就需要 命名管道（FIFO）。你一定在想，FIFO 不是先进先出的意思吗，为什么这里变成了命名管道呢？这是因为管道在写入数据时采取的也是先入先出的策略。下面这个系统调用允许我们建立一个命名管道：

```cpp
#include <sys/types.h> 
#include <sys/stat.h> 
int mkfifo(const char* pathname, mode_t mode);
```

 我们可以看到，这个系统调用的第一个参数是一个路径名称，这个路径名称就是我们的管道的名称；第二个参数mode表示的是这个命名管道的权限可以被umask命令修改。

**命名管道与匿名管道的不同**在于命名管道自创建以后就可以被任何进程像使用一般文件那样使用；即使创建管道的进程已经退出，管道仍然存在，只有在被删除后才会消失。

**它不同于一般文件的一点**在于读取数据的进程和写入数据的进程必须同时出现；假如一个进程要求读取数据，而没有进程正在向这个管道写入数据，那么它就会被阻塞（block），直到有写入数据的进程出现时它才会开始读取数据并最终返回。

### epoll()

epoll()，它被用于在一段时间内同时等待多个文件产生我们希望的 I/O 事件；在这段时间结束后，epoll()会返回这段时间里产生等待的 I/O 事件的文件数量，并允许我们通过一个指向包含 I/O 事件的数据结构的指针遍历所有产生的事件。比如，如果我们建立多个子进程，并与每个子进程之间建立一个管道，接着等待所有子进程向管道中写入数据，我们就可以将所有子进程管道的读取端加入epoll()等待，epoll()就在一段时间后返回写入数据的子进程的数量。 

虽然我们把epoll()叫做一个函数，但它实际是一组函数，由三个函数组成，它们分别被用来初始化一个epoll()实例、增减或修改被等待的事件和等待事件发生。

在**初始化epoll()**时我们需要调用下面这个函数：

```cpp
#include <sys/epoll.h>
int epoll_create(int size); 
```

参数size表示的是epoll()需要监控的文件描述符的总数量，在 Linux 2.6.8 之前的系统中被系统用于估计epoll()所需的内存大小并分配该内存；在 Linux 2.6.8 之后，由于系统具备了动态分配内存的能力，size这个参数会被自动忽略，但我们仍需要输入一个大于 0 的数，以保证新版本系统仍能兼容老版本系统。 这个函数成功时返回的值是一个非零的**文件描述符**，代表一个新的epoll()实例。注意，在结束使用epoll()后我们需要关闭这个文件描述符，以便于系统回收资源。

在初始化epoll()实例后，这个实例还没有任何用处，因为我们没有实际开始等待任何 I/O 事件。向epoll()中加入新的等待事件、从epoll()中删除等待事件和修改epoll()中现有的等待事件这三种功能都可以通过一个函数实现，这个函数就是： 

```cpp
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); 
```

它的第一个参数epfd是代表epoll()实例的文件描述符，也就是我们刚才调用epoll_create()返回的值；op有三个可能的值： 

```cpp
EPOLL_CTL_ADD // 代表添加新的文件描述符
EPOLL_CTL_MOD // 代表修改一个正在被监控的文件描述符
EPOLL_CTL_DEL // 代表删除一个正在被监控的文件描述符
```

 而fd自然就是被添加、修改或删除的 I/O 事件所关联的文件。