### 进程、地址空间、线程

由于计算机所拥有的物理资源有限，当多个程序在计算机上同时运行时，它们不可能连续地在处理器上运行或占用全部内存，因此我们需要进程的抽象在用户的一侧隐藏上下文切换等细节。进程作为运行的程序的抽象，包含了一个程序的运行状态和这个程序所用的抽象内存及其中存储的数据。我们将后一部分，即一个进程可以使用的全部内存的地址和它们存储的数据，称为这个进程的 **地址空间**（address space）。我们可以将进程笼统地看做是一个或多个线程与一个地址空间的结合。

在讲解进程在系统中的实现方式以前，让我们先明确这一实现方式需要达到的目的：一方面，进程的结构必须能够囊括一个进程的运行状态，在由于中断、异常或系统调度进入内核态时我们应该能够将进程的运行状态放入内存中的某一位置，使我们可以在某一个时间点根据进程的优先级接着这次的进度再次运行该进程；另一方面，由于进程在用户一侧对内存进行了抽象，我们需要在系统一侧包含从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址和其中存储的数据。

为了实现上述的第一个目的，即在进程中存储其运行状态，我们将在进程中存储处理器状态寄存器、指令计数器、栈指针、通用寄存器等代表了进程目前的运行状态的值。由于现代计算机中往往有多个核或多个处理器，我们的程序可以达到 并行（parallelism，即在物理时间上同时运行，区别于多个进程在处理器上的并发（concurrency）），因此同一个进程可能同时包含有多个不同的运行状态。为了更好地区分进程在一个处理器上的运行状态和进程本身的运行状态，我们在此引入 线程（thread） 的概念。每个线程拥有一个 线程控制块（thread control block, TCB），用来存储我们上述提到的处理器状态寄存器、指令计数器、栈指针、通用寄存器等数值，但同一个进程中的所有线程都共享同一个地址空间。

![img](https://i.loli.net/2020/10/10/FtKi6s4v5XuJd9o.png)

在前文我们已经提到，一个用户进程所看到的内存空间是抽象的，区别于实际的物理内存，因此为了支持进程从抽象内存获取物理内存中存储的信息，我们需要在进程中包含从抽象内存向物理内存的映射，即该系统所用的地址转换方法所需要的信息。地址转换有很多种不同方法，包括分页存储、分段存储等，它们都需要不同的信息来实现地址转换；我们将在下一章中详细介绍这些方法，这里我们将以最为简单的 Base and Bound 作为例子来解释这一概念。 

在 Base and Bound 方法中，系统将一段连续的物理内存分配给一个进程，Base 代表基地址，即系统分配给一个进程的可用内存的起始地址，Bound 代表这个进程可用的内存的最高地址。为了读写物理内存，我们将基地址与抽象内存地址相加，获得实际地址；只要实际地址不大于 Bound，内核就会允许进程进行该操作。因此在这个方法中，为了实现进程地址空间的抽象，进程在系统一侧的数据结构中必须包括这段可用的内存的基地址、可用长度。

为了能在一个进程开始运行的时候方便地载入上面提到的两方面的数据，我们需要一个数据结构来包含这些数据。这个数据结构就是 **进程控制块**（Process Control Block, PCB）。对于内核来说，它是进程存在的唯一标识。进程控制块中存储的信息除了上面提到的实现地址转换的信息和表示运行状态的线程信息以外，还包括了很多系统在调度进程时需要的信息，比如进程号、进程所处状态、进程的优先级等等。需要注意的是，我们不会将整个地址空间中包含的地址及其数据都存储在进程控制块里；我们只需要可以帮助我们从抽象内存地址获得实际物理地址的方法，而实际数据仍然存储在内存的对应位置中。 

由于进程控制块中的信息包含了优先级、基地址、可用地址范围等用户进程不应该有权限修改的信息，用户进程不应该有权限修改进程控制块。因此我们将进程控制块存储在内核空间中。

### 进程状态与用户态和内核态之间的切换

进程控制块中包含了进程的状态；那么，什么是进程的状态呢？我们已经提到过，一个进程可能在运行一段时间后被切换出去，一段时间后继续运行。显然，进程至少需要两个状态——**运行态**（running） 与 就绪态（ready）。进程在运行态中运行一段时间后被切换出去，排入就绪队列，等待继续运行。在三态模型中，进程还有一个状态，即 **等待态**（wait）。在这个状态中，进程在等待某一事件完成，不会被排入就绪队列，直到该事件发生后，进程才会被排入就绪队列，可能被选为下一个运行的进程。这一等待事件可能包括等待系统调用完成，等待获得某一个锁或收到某一信号量的信号等等，我们在接下来的章节中会详细讲解这些内容。现在你只需要知道，处于就绪态的进程不会因为遇到任何事件而无法进入等待态；处于等待状态的进程在事件发生后考虑到优先级等问题，必须先回到就绪状态而不能直接运行。

除三态模型外，五态模型也是一种常见的进程状态转换模型。相比三态模型，五态模型多引入了 **新建态**（new） 和 **终止态**（exit）。新建态对应着进程被创建时尚未加入就绪队列的状态。为了建立一个新的进程，内核需要给进程分配资源（如：建立进程控制块）、建立必要的管理信息；在这个过程中，进程就处于新建态。相对的，终止态对应的是进程已经结束但尚未被系统撤销的状态。处于终止态的进程虽然已经结束，但其获得的资源还未被系统回收，因此系统仍然可以获得该进程结束时的信息。

除三态模型外，五态模型也是一种常见的进程状态转换模型。相比三态模型，五态模型多引入了 新建态（new） 和 终止态（exit）。新建态对应着进程被创建时尚未加入就绪队列的状态。为了建立一个新的进程，内核需要给进程分配资源（如：建立进程控制块）、建立必要的管理信息；在这个过程中，进程就处于新建态。相对的，终止态对应的是进程已经结束但尚未被系统撤销的状态。处于终止态的进程虽然已经结束，但其获得的资源还未被系统回收，因此系统仍然可以获得该进程结束时的信息。

![img](http://res.jisuanke.com/img/upload/20160524/b49f9d2d90d601cb3ff832695ce1727592adba5b.png)

### 子进程和父进程

为了产生新的进程，我们必须使用一个新的系统调用，fork()。 

fork()被包含在unistd.h中。这个函数不需要任何参数；它会直接创建一个新的进程，将现在运行的进程的处理器状态、地址空间直接拷贝到新进程中，因此新进程也会从fork()对应的指令开始运行。我们称这个新进程为调用fork()的进程的子进程，称创建子进程的进程为父进程。fork()执行完毕后会返回一个进程标识 ID（pid = process ID），可以被用来区分父进程与子进程。在父进程中返回的进程标识 ID 是新创建的子进程的进程标识 ID，而在子进程中返回的进程标识 ID 为 0。我们可以利用if语句判断进程标识 ID 是否为 0，从而使子进程与父进程执行不同的命令。

```cpp
int pid = fork();
```

一个进程在运行结束或产生重大错误（如：企图越权使用内核的特权指令）后会被系统终止。但我们在由fork()产生的子程序中也可以用exit()系统调用主动结束这个程序。

```cpp
void exit(int status);
```

exit()函数在stdlib.h头文件中；它的参数status表示这个进程退出时的结束状态。当我们用这个函数结束一个子进程时，status会作为子进程的结束状态被提供给wait()的第一个参数。 

```cpp
pid_t wait(int* stat_loc); 
```

wait()被包含在sys/wait.h中。它的参数stat_loc，是一个可以被用来储存等待的进程的 结束状态值（exit code，一个代表子进程是否成功退出的整数；如成功则为 0，否则为对应的错误数字） 的指针。但我们也可以把这个设为NULL，函数仍可以正常运行。wait()函数会使父进程的状态变为等待态，直到父进程的所有子进程中的 一个 成功退出并返回结束状态值，父进程才可以进入就绪状态，准备继续运行；如果在wait()被调用时已经有可用的结束状态值，那么wait()会立即返回。wait()返回的值是返回结束状态值的子进程的进程标识 ID；如果在等待过程中出现了错误（如已经没有可等待的子进程），那么wait()将返回 -1。注意，父进程不能等待子进程的子进程！

```cpp
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
int main() {
    printf("%s\n", "我是鸣人！");
    /*YOUR CODE HERE*/
    int pid = fork();
    if(pid != 0){
        int status;
        int result = wait(&status);
        if(result == -1 || status != 0){
            printf("%s\n","可恶，又失败了，再来一次！");
            return -1;
        } else {
            printf("%s\n","我负责性质变化！");
        }
    } else {
        int secondpid = fork();
        if(secondpid != 0){
            int new_status;
            int new_result = wait(&new_status);
            if(new_result == -1 || new_status != 0){
                exit(-1);
            } else {
                printf("%s\n","我负责形态变化！");
            	exit(0);
            }
            
        } else {
            printf("%s\n","我负责产生查克拉！");
			exit(0);
    	}
    }
    return 0;
}
```

wait()的第一个参数可以得到exit()的参数，也就是退出的子进程的结束状态值，我们可以通过wait()的返回值获得那个退出的子进程的进程识别 ID。

但wait()并不能帮我们直接从子进程中获得任何数值，那么我们为什么要使用这个函数呢？一种情况是，我们可能希望在子进程中执行的某些指令在我们继续执行父进程以前完成，此时我们可以用wait等待这个子进程执行完毕（注意，如果我们不使用wait，子进程也 可能 比父进程先完成，这取决于内核对不同进程的调度，但我们希望子进程 一定 先完成，所以使用wait）；另一种情况是，父进程即将退出，为了避免僵尸进程的出现，父进程必须等待直至所有子进程结束。

创建新进程在实际编程中有很多应用，比如在本课程的最后我们学习网络编程时就会看到，每当服务器接收到请求，主进程就会用fork()产生出一个进程，处理那个请求；父进程仍然会继续在网络上等待其它请求的到来。 

在本节的最后我们想讲一讲wait的一个变体，waitpid()。

```cpp
pid_t waitpid(pid_t pid, int* stat_loc, int options); 
```

waitpid()与wait()不同的一点在于你可以通过在pid参数里指定一个进程标识 ID 来等待一个有特定的进程标识 ID 的进程—— 当pid为一个大于零的数的时候waitpid等待的就是进程标识 ID 等于pid的子进程； 当pid为 -1 时，我们等待所有子进程中的任何一个；当pid为 0 时，我们等待所有进程组标识 ID 与父进程相同的子进程；当pid小于 −1 时，我们任何进程组标识 ID 为 pid 的绝对值的进程。 stat_loc与wait()中的stat_loc有同样的作用；options将一些针对这个函数的特殊的控制选项（如：我们可以选择在没有子进程退出时立即返回，而不做等待）用或运算连接在一起，我们在这里不对所有选项一一进行介绍。当 options 被设为 0 时，waitpid 没有任何特殊选项。因此，我们可以知道，当pid为 -1、options为 0 时，waitpid()与wait()效果相同。

### exec()

利用fork()返回的进程标识 ID，我们可以在子进程中执行和父进程中不同的指令；但如果我们想要运行完全不同的程序，这种办法可能就不是最好的。因此我们在此向你介绍一个新的系统调用，execve()。在 Linux 系统中，我们实际比起系统调用本身更经常使用exec()组包含的六个函数，但此处我们为了让你了解系统调用的实际过程将先给你介绍系统调用，然后再介绍这六个建立在系统调用基础上的函数。 

```cpp
int execve(const char* filename, char* const argv[], char* const envp[]); 
```

这个函数将在 **现在运行的** 进程中以argv中存储的字符串为参数运行由filename指向的可执行程序，并将envp中存储的“变量=数值”对作为环境变量代入这个程序。根据传统，argv中的第一个参数必须与filename一致，真正的参数从第二个开始。execve会以filename的程序覆盖现在进程中正在运行的程序，因此所有在execve函数之后的行都只会在execve失败之后被执行，我们可以通过在后面加入打印语句等方法标识execve运行失败。

基于execve()的还有六个函数；他们都具有在现有的进程中打开某一可执行文件、覆盖现有程序执行的功能。 

```cpp
int execl(const char* path, const char* arg, ...);
int execlp(const char* file, const char* arg, ...);
int execle(const char* path, const char* arg, ...,
           char* const envp[]);
int execv(const char* path, char* const argv[]);
int execvp(const char* file, char* const argv[]);
int execvpe(const char* file, char* const argv[],
            char* const envp[]); 
```

我们可以将这些函数表示为：“exec + l/v + p/e/pe”，所以这六个函数主要有两处不同。

第一处不同（l/v）在参数中表现为“execl”类函数将所有参数作为一整个字符串代入，而“execv”类函数将参数分别放入一个字符串的数组中，将数组作为参数代入函数运行。

第二处不同（p/e/pe）表现为包含 p（代表 path）的函数可以模仿计算机中壳的功能，在“file”中不含“/”时应用环境变量 PATH 中的目录来寻找可执行文件，而包含 e（代表 environment）的函数可以像execve一样将“变量=数值”对作为环境变量代入程序。

所有上述函数的常见用法是先由当前运行的进程调用fork()产生新进程，然后在新进程中用exec()类函数运行新程序。你可能会认为这样应用fork()复制了全部父进程的地址空间后又马上弃置不用、浪费了很多处理器时间，但实际上 Linux 系统采用了 copy_on_write 技术，也就是说只有在某一个数据被修改时那个数据才会被实际复制到子进程的地址空间，所以当fork()之后直接运行exec()时，父进程的地址空间不会被复制过来。 

fork()，wait()，exit()，和exec()是对于进程来讲最重要的几个函数。