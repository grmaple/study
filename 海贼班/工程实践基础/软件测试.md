### 软件测试

在介绍软件测试之前，我们先来回顾一个你应该之前有所耳闻的名词——bug。 

什么是 bug？bug 即 软件缺陷，是指存在于软件之中的，不希望或不可接受的故障。

软件测试是一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。说得直白一些，软件测试是发现错误、衡量软件质量和对是否满足要求进行评估的过程。 

说了这么多，我们为什么要进行软件测试呢？当不测试的代价比测试更大时，我们就要进行软件测试。

举个简单的例子：当你在完成平时的编程作业时，往往是不需要进行测试，或者说，不需要进行严格的测试的——当你的程序出现错误后，只是被扣掉几分而已。然而当开发手术操控系统、载人飞船系统、甚至核弹控制系统的时候，一个非常微小的错误可能会导致性命攸关，甚至是地球毁灭。这种情况下，测试就显得非常重要了。

##### 单元测试（unit test） 

是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。**单元测试往往由开发人员自己编写**，软件开发人员修改一次代码通常就要进行至少一次单元测试，并且往往使用的开发语言或框架会提供现成的单元测试工具。

在 C++ 中，可以用 断言（assert） 来实现单元测试。

```cpp
//fib.h
int fib(int x){
    if(x==1){
        return 1;
    } else if(x==3){
        return 2;
    } else {
        return fib(x-1)+fib(x-2);
    }
}
//test.cpp
#include <cassert>
#include "fib.h"
int main(){
    assert(fib(1)==1);
    assert(fib(2)==1);
    assert(fib(10)==55);
    return 0;
}
//可以发现一处bug
```

### 白盒测试

事实上，就像计算机中的 0/1 一样，在软件测试中，也有这样一对测试方法：白盒测试和黑盒测试。而单元测试，是白盒测试这一大类中的一种测试方法。 

那么，究竟什么是白盒测试？ 白盒测试（white-box testing） 是一种考虑系统或组件内部机制的测试方法，常被程序开发者用于对代码进行自测。比如我们前面提到的单元测试，就需要软件开发者自己设计单元测试代码，并执行测试。 

除了单元测试外，白盒测试还包括代码审查、集成测试等常用的测试方法。

##### 代码审查（code review） 

是指对程序进行系统化地审查，往往通过同事或同行评审的方式进行。代码审查的目标是找出并修正代码中的错误及不符合规范的地方，提升软件质量和可维护性，减少之后发现错误的几率。 

代码审查有很多种形式，包括结对编程、非正式的代码阅读和正式的代码审查。 

代码审查不是简单地把代码拿给同事看，更不是一个流于形式的步骤。审查的同事要对代码中有疑问、不符合规范、效率低的地方对开发者进行询问，开发者必须对这些有时候看起来“吹毛求疵”的问题给出详细解答，并在之后对找出的问题进行修复。如此“审查---修复”不断往复，直到审查者通过为止。 

一些新入行的程序员往往会很怕 code review，担心会因为代码的各种错误被同事或上司责备。切不可有如此的想法，只要这次被发现的错误以后努力避免，经过一段时间就会发现自己的能力有了质的提升。

##### 集成测试（integration testing, I&T） 

是一种将若干独立的软件模块组装起来进行测试的方法。 

集成测试往往会在单元测试之后，测试的是多个模块之间的接口，包括模块之间的调用关系和同步控制、模块之间的通信、第三方中间件等。

在进行单元测试时，我们往往使用 **代码覆盖**（code coverage） 来确保源代码被测试完全。 

根据预期覆盖程度的不同，有如下一些对应的覆盖准则： 

- 子程序覆盖（function coverage）：测试用例是否调用了程序的每一个子程序。 
- 语句覆盖（statement coverage）：测试用例是否执行了程序的每一条语句。 
- 分支覆盖（branch coverage）：测试用例是否能让程序中的每个判定至少取值为true、false各一次。 
- 条件覆盖（condition coverage）：测试用例是否能让程序中每个判定的每个条件都至少取值为true、false各一次。

为此，又有了要求更为苛刻的如下两种覆盖准则：

- 条件/分支覆盖（condition/decision coverage）：同时满足分支覆盖和条件覆盖。 
- 组合条件覆盖（multiple condition coverage）：测试用例使得每种条件取值组合都被执行一次。

![img](https://i.loli.net/2020/10/10/GIkEnYp8bHwgNDj.png)

在上图中，自上而下的覆盖程度由高到低，并且箭头的含义为：A 指向 B 意味着满足 A 就一定要满足 B，即 B 是 A 的必要条件。

当我们在利用代码覆盖准则进行单元测试时，往往按如下流程进行：

- 选择预期覆盖程度对应的覆盖准则； 
- 选择测试路径以满足选定的测试准则； 
- 根据测试路径设计测试用例的输入数据； 
- 根据输入数据确定预期输出数据，完成单元测试的开发。

### 黑盒测试（black-box testing） 

是一种无需观察程序内部，只通过给定的输入和输出对程序进行测试的方法。 

黑盒测试往往又被称为功能测试或基于文档的测试。和白盒测试不同的是，黑盒测试由测试人员而非开发人员执行，会把被测程序当成一个“黑盒子”，就像下面这张图。

![image-20201010170028034](https://i.loli.net/2020/10/10/TC3gYLDPvFyfo7J.png)

相比于白盒测试，黑盒测试有很多优势： 

- 测试人员无需了解程序内部代码实现 
- 测试用例不依赖程序内部的设计 
- 可以从用户的角度出发进行测试 

当然，缺点也很明显，就是代码中很多隐藏的缺陷难以被发现，因为黑盒测试不能像白盒测试那样，让测试用例覆盖到所有分支和条件。

在进行黑盒测试时，最重要的就是测试用例的设计。测试用例指的就是用来验证“黑盒”正确性的输入、输出数据。

一个最经典的黑盒测试例子就是在线题库的判题功能，它实际上是对用户提交的代码进行自动化的黑盒测试。而编写题目的测试数据，实际上就是在设计黑盒的测试用例。